---
文档类型: 架构设计
创建日期: 2026-02-05
最后更新: 2026-02-05
维护人: X28技术团队
文档版本: v0.1
适用范围: 核心引擎 - 运行控制与调试 - 仿真循环控制
状态: 草案
依赖文档:
  - docs/00_文档总览/规范/11_架构设计.md
  - docs/02_核心引擎/02_系统分组与执行时序/01_系统分组与执行时序_架构设计.md
  - docs/02_核心引擎/03_TimeSlice与分帧策略/01_TimeSlice与分帧策略_架构设计.md
---

# 仿真运行控制 架构设计

# 1 设计概述

## 1.1 本文档定义

本文档定义仿真循环控制（run-by-step / run-until）的架构与约束，包括：如何切换 pacemaker 模式、如何在 fixed tick 完成后续跑、以及 GAS/Physics 的配置化策略如何接入。

## 1.2 设计目标

1. 可调试：支持暂停与单步推进，且推进顺序与业务裁决一致。  
2. 可自动化：支持 run-until 类推进到条件满足（窗口关闭/物理休眠/超限退出）。  
3. 可观测：每次 run-until 的完成原因必须可记录与可回放。  
4. 不重入：控制器不得在同一推进窗口内递归推进，避免半状态。  

## 1.3 设计思路

1. “推进”由引擎主循环统一承载：控制器只能请求下一步（TurnBased.Step）。  
2. “条件判定”在 fixed tick 完成回调处执行：保证状态稳定且可观测。  
3. 运行策略（GAS StepPolicy、Physics2D TickPolicy）用 version 机制支持动态配置化更新。  

# 2 功能总览

## 2.1 术语表

| 术语 | 含义 |
|---|---|
| run-by-step | 手动推进固定步（fixed tick） |
| run-until | 自动推进直到条件满足或超限 |
| TurnBasedPacemaker | 手动步进 pacemaker（累计要跑的 fixed tick） |
| SimulationLoopController | 切换模式与 step 的统一门面 |
| policy version | 策略参数版本号，变化时强制生效 |

## 2.2 功能导图

```
User/Tool command
  │
  ▼
SimulationLoopController.SetTurnBased / Step(N)
  │ accumulates fixed ticks
  ▼
GameEngine.Update(dt)
  │
  └─ Pacemaker consumes steps → CooperativeSimulation.Step(...)
         │
         ▼
     OnFixedStepCompleted callback
         ├─ Physics2DController.AfterPhysicsFixedTick()
         └─ GasController.AfterFixedTick()
               └─ if not done → loop.Step(1)
```

## 2.3 架构图

```
┌─────────────────────────────┐
│ SimulationLoopController     │  mode switch + Step(N)
└──────────────┬──────────────┘
               │ sets
               ▼
┌─────────────────────────────┐
│ IPacemaker (Realtime/Turn)   │  produces fixed ticks
└──────────────┬──────────────┘
               │ drives
               ▼
┌─────────────────────────────┐
│ CooperativeSimulation        │  phase stepping + time-slice
└──────────────┬──────────────┘
               │ callback
               ▼
┌─────────────────────────────┐
│ RunUntil Controllers         │  Gas / Physics2D
└─────────────────────────────┘
```

## 2.4 关联依赖

- Phase 顺序与推进语义：`docs/02_核心引擎/02_系统分组与执行时序/01_系统分组与执行时序_架构设计.md`  
- TimeSlice 与预算熔断：`docs/02_核心引擎/03_TimeSlice与分帧策略/01_TimeSlice与分帧策略_架构设计.md`  

# 3 业务设计

## 3.1 业务用例与边界

用例：

- 调试：暂停仿真，逐步推进 1..N 个 fixed tick 观察状态变化。  
- 自动化测试：运行到 “GAS effect windows closed” 或 “Physics2D sleeping”。  

边界：

- 控制器不允许改变 PhaseOrder 与业务裁决边界，只负责推进节奏与条件判定。  
- 控制器不得绕过 pacemaker/engine 直接调用系统 Update。  

## 3.2 业务主流程

### 3.2.1 run-by-step（统一口径）

1. 切换为 TurnBased 模式：`SimulationLoopController.SetTurnBased()`  
2. 累积要跑的 fixed tick：`SimulationLoopController.Step(N)`  
3. 由引擎在后续 Update 中消耗并推进 fixed tick。  

### 3.2.2 run-until（GAS/Physics2D）

1. 初始化 run 状态（最大 tick 上限、模式、策略参数）。  
2. 切到 TurnBased 并触发第一步。  
3. 在 `OnFixedStepCompleted` 回调中检查条件：  
   - 满足条件：记录完成原因并结束。  
   - 不满足：请求下一步 `Step(1)`。  

## 3.3 关键场景与异常分支

- MaxFixedTicks：达到最大步数上限必须停止，避免死循环。  
- BlockedOnInput：GAS 若等待输入且链为空，必须停止并报告原因。  
- MissingRuntimeState：运行态组件缺失必须停止（fail-fast）。  

# 4 数据模型

## 4.1 概念模型

- LoopMode：Realtime/TurnBased  
- RunState：runActive、mode、maxFixedTicks、elapsed、reason  
- Policy：GAS StepPolicy、Physics2D TickPolicy（带 version）  

## 4.2 数据结构与不变量

1. `Step(N)` 只累积要跑的 fixed tick，不直接推进系统。  
2. run-until 的条件判定只能发生在 fixed tick 完成回调之后。  
3. policy 更新必须通过显式 setter 触发 version 增量。  

## 4.3 生命周期/状态机

```
Idle
  ├─ RunStarted → Running
Running
  ├─ ConditionMet → Completed
  ├─ BlockedOnInput → Completed
  ├─ MaxFixedTicks → Completed
  └─ Cancel → Completed
```

# 5 落地方式

## 5.1 模块划分与职责

- SimulationLoopController：模式切换与 step 门面。  
- TurnBasedPacemaker：累积并消费要跑的 fixed tick。  
- GasController/Physics2DController：run-until 的条件判定与完成事件。  
- Policy：提供可配置的推进策略参数（version 化）。  

## 5.2 关键接口与契约

- `src/Core/Engine/Pacemaker/SimulationLoopController.cs`  
- `src/Core/Engine/Pacemaker/IPacemaker.cs`（Realtime/TurnBased）  
- `src/Core/Gameplay/GAS/GasController.cs`（RunUntilEffectWindowsClosed）  
- `src/Core/Engine/Physics2D/Physics2DController.cs`（RunForFixedTicks/RunUntilSleeping）  

## 5.3 配置入口与版本策略

运行控制相关的“配置化更新”以 ConfigPipeline 的 JSON 片段合并为准，并在加载期做 fail-fast 校验：

- GAS 时钟配置：`src/Core/Gameplay/GAS/Config/GasClockConfig.cs`  
  - 默认路径：`GAS/clock.json`  
  - 字段：`StepEveryFixedTicks`、`Mode`（Auto/Manual/Paused）  
- Physics2D 时钟配置：`src/Core/Engine/Physics2D/Physics2DClockConfig.cs`  
  - 默认路径：`Physics2D/clock.json`  
  - 字段：`PhysicsHz`、`MaxStepsPerFixedTick`  

策略对象（`GasClockStepPolicy` / `Physics2DTickPolicy`）通过 setter 变更并递增 version，用于运行态切换参数时的显式生效口径。

## 5.4 运行时关键路径与预算点

- 关键路径：GameEngine 的 fixed tick 完成回调触发 run-until 的判定与续跑。  
- 预算点：run-until 仍受 TimeSlice 预算与 BudgetFuse 影响；超限必须可观测并退出。  

# 6 与其他模块的职责切分

## 6.1 切分结论

- 引擎负责推进窗口与回调；控制器负责条件判定与续跑请求。  
- GAS/Physics 运行策略由各自 policy 管理，但必须通过 ContextKeys 显式注入与更新。  

## 6.2 为什么如此

把推进与判定拆开可以避免重入推进导致半状态，同时保证条件判定发生在一致性视图稳定点。

## 6.3 影响范围

- 若未来新增 run-until 控制器（例如 Graph/Navigation），必须复用同一回调判定口径并提供完成原因枚举。  

# 7 当前代码现状

## 7.1 现状入口

- Loop 控制：`src/Core/Engine/Pacemaker/SimulationLoopController.cs`  
- 引擎回调挂接：`src/Core/Engine/GameEngine.cs`  
- GAS run-until：`src/Core/Gameplay/GAS/GasController.cs`  
- Physics2D run-until：`src/Core/Engine/Physics2D/Physics2DController.cs`  
- GAS StepPolicy：`src/Core/Gameplay/GAS/GasClockStepPolicy.cs`  
- Physics2D TickPolicy：`src/Core/Engine/Physics2D/Physics2DTickPolicy.cs`  

## 7.2 差距清单

| 设计口径 | 代码现状 | 差异等级 | 风险 | 证据 |
|---|---|---|---|---|
| run-until 条件在回调判定 | 已在 fixed tick 完成回调链路调用 | 低 | 低 | `src/Core/Engine/GameEngine.cs` |
| policy 配置化更新 | 已通过 setter + version 实现 | 低 | 低 | `src/Core/Gameplay/GAS/GasClockStepPolicy.cs` |
| 统一完成原因枚举 | 当前以字符串 reason 输出 | 中 | 中 | `src/Core/Gameplay/GAS/GasController.cs` |

## 7.3 迁移策略与风险

- 将完成原因收敛为受控枚举，减少字符串漂移导致的对齐成本。  

# 8 验收条款

1. run-by-step 可稳定推进 N 个 fixed tick，且不改变 PhaseOrder。  
2. run-until 在 MaxFixedTicks/BlockedOnInput/ConditionMet 时可停止并输出完成原因。  
3. 控制器不发生递归推进：所有续跑只能通过 `Step(1)` 请求下一步。  
