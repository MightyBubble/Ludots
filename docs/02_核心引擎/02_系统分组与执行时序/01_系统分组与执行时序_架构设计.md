---
文档类型: 架构设计
创建日期: 2026-02-05
最后更新: 2026-02-05
维护人: X28技术团队
文档版本: v0.1
适用范围: 核心引擎 - 系统分组与执行时序
状态: 草案
依赖文档:
  - docs/00_文档总览/规范/11_架构设计.md
  - docs/02_核心引擎/01_总架构/01_GameEngine_架构设计.md
---

# 系统分组与执行时序 架构设计

# 1 设计概述

## 1.1 本文档定义

本文档定义核心引擎的 SystemGroup（Phase）分组、固定执行顺序，以及它们与预算推进（TimeSlice）的关系。

## 1.2 设计目标

1. 单一真源：同一世界实例内 Phase 顺序固定，不允许运行态重排。  
2. 确定性：同一输入序列回放一致，不依赖 wall-clock。  
3. 可预算化：允许在不改变裁决边界的前提下切片推进。  

## 1.3 设计思路

1. 用 SystemGroup 表达“输入收集→效果处理→清理发布”的稳定边界。  
2. Phase 顺序由 cooperative simulation 固化为代码常量。  
3. time-slice 只改变耗时分摊，不改变同一 FixedTick 内的裁决顺序。  

# 2 功能总览

## 2.1 术语表

| 术语 | 含义 |
|---|---|
| Phase/SystemGroup | 系统分组与执行阶段 |
| FixedTick | 固定步推进单位 |
| time-slice | 在同一 FixedTick 内的暂停/恢复机制 |
| BudgetFuse | 超过最大切片数后的熔断 reset |

## 2.2 功能导图

```
FixedTick
  │
  ▼
PhaseOrder[0..N]  (fixed)
  │
  ├─ NormalSystem.Update(dt)
  └─ TimeSlicedSystem.UpdateSlice(dt, budgetMs)  (may pause/resume)
```

## 2.3 架构图

```
┌─────────────────────────────┐
│ GameEngine                   │  Phase 注册与调度
└──────────────┬──────────────┘
               │ owns
               ▼
┌─────────────────────────────┐
│ PhaseOrderedCooperativeSim   │  PhaseOrder + 暂停/恢复
└─────────────────────────────┘
```

## 2.4 关联依赖

- TimeSlice 与分帧策略：`docs/02_核心引擎/03_TimeSlice与分帧策略/00_总览.md`  

# 3 业务设计

## 3.1 业务用例与边界

用例：在压力场景（实体数大、任务多）下保持稳定帧耗，允许把单个 FixedTick 分摊到多个渲染帧完成。

边界：

- PhasePipeline 不定义业务模块（避障/导航/战斗）的具体算法，只提供可插槽、可预算的执行框架。  
- 不为历史调用方式保留静默兼容分支；破坏性变更必须通过迁移与强校验解决。  

## 3.2 业务主流程

```
RenderFrame(dt)
  │
  ├─ Pacemaker：根据 dt 产生 0..k 个 FixedTick
  │
  └─ 对每个 FixedTick：
        CooperativeSimulation.Step(fixedDt, remainingBudgetMs)
            按 PhaseOrder 推进系统
            预算不足→暂停，下一切片继续
```

## 3.3 关键场景与异常分支

- 预算耗尽：停止推进更多系统/更多 FixedTick，等待下一渲染帧继续。  
- 超过最大切片数：触发 BudgetFuse，reset 到干净态，避免半状态。  

# 4 数据模型

## 4.1 概念模型

- `SystemGroup`：Phase 枚举  
- `PhaseOrder`：固定数组顺序  
- `phaseIndex/systemIndex`：暂停/恢复游标  

## 4.2 数据结构与不变量

1. `PhaseOrder` 必须覆盖所有参与调度的 SystemGroup。  
2. 同一 SystemGroup 内系统顺序必须稳定（注册顺序固化）。  
3. 暂停/恢复游标必须可被 reset（BudgetFuse）。  

## 4.3 生命周期/状态机

```
Idle
  ├─ Step() → Running
Running
  ├─ budget ok → Running
  ├─ budget exhausted → Paused
  ├─ all done → Completed → Idle
  └─ fuse → Reset → Idle
Paused
  └─ next slice → Running
```

# 5 落地方式

## 5.1 模块划分与职责

- GameEngine：注册系统到 SystemGroup，并提供运行入口。  
- CooperativeSimulation：执行 PhaseOrder 并实现暂停/恢复。  
- Pacemaker：产出 FixedTick，并提供外层预算与切片上限。  

## 5.2 关键接口与契约

- `IPacemaker`：`src/Core/Engine/Pacemaker/IPacemaker.cs`  
- `ICooperativeSimulation`：`src/Core/Engine/Pacemaker/ICooperativeSimulation.cs`  
- `ITimeSlicedSystem`：由业务系统实现（示例：`src/Core/Gameplay/GAS/Systems/AbilityTaskSystem.cs`）  

## 5.3 运行时关键路径与预算点

- 关键路径：`CooperativeSimulation.Step` 在预算内循环推进系统。  
- 预算点：每次切片推进消耗 `timeBudgetMs`，并受 `maxSlicesPerLogicFrame` 限制。  

# 6 与其他模块的职责切分

## 6.1 切分结论

- 引擎负责“何时推进、推进顺序、预算与恢复”。  
- 业务模块负责“如何把长任务拆成可中断工作单元”，并提供 reset 行为。  

## 6.2 为什么如此

把预算与顺序固化在引擎层，才能在任何业务组合下维持回放一致性与可预测耗时。

## 6.3 影响范围

- 任何长任务若不做 time-slice，将直接破坏预算口径。  
- 任何在 Phase 之间偷写共享状态的实现都会破坏一致性视图。  

# 7 当前代码现状

## 7.1 现状入口

- `src/Core/Engine/GameEngine.cs`
- `src/Core/Engine/Pacemaker/PhaseOrderedCooperativeSimulation.cs`
- `src/Core/Engine/Pacemaker/IPacemaker.cs`

## 7.2 差距清单

| 设计口径 | 代码现状 | 差异等级 | 风险 | 证据 |
|---|---|---|---|---|
| Phase 顺序固定 | 已固定为常量数组 | 低 | 低 | `src/Core/Engine/Pacemaker/PhaseOrderedCooperativeSimulation.cs` |
| BudgetFuse 必须 reset | 已实现 reset | 低 | 低 | `src/Core/Engine/Pacemaker/IPacemaker.cs` |
| 长任务必须 time-slice | 依赖业务系统自觉遵守 | 中 | 中 | `src/Core/Engine/Pacemaker/PhaseOrderedCooperativeSimulation.cs` |

## 7.3 迁移策略与风险

- 对于已存在的长任务系统，优先改造为 `ITimeSlicedSystem`，并补齐 reset 行为与验收用例。  

# 8 验收条款

1. Phase 顺序固定且可定位：以 `src/Core/Engine/Pacemaker/PhaseOrderedCooperativeSimulation.cs` 为真源。  
2. BudgetFuse 触发后不残留半状态：reset 后可继续推进并保持回放一致。  
3. 任意 time-sliced 系统可暂停/恢复，且不破坏同一 FixedTick 内的裁决顺序。  
