---
文档类型: 架构设计
创建日期: 2026-02-05
最后更新: 2026-02-05
维护人: X28技术团队
文档版本: v0.1
适用范围: 04_游戏逻辑 - 导航寻路 - 分层导航与预算化
状态: 草案
---

# 导航寻路 架构设计

# 1 设计概述

## 1.1 本文档定义

本文档定义 Ludots 在 64km×64km 大世界下的导航寻路总体架构形态与落地方式，目标是把“寻路能力”从具体算法与具体图实现中抽象出来，形成可替换、可预算、可审计的系统边界。

边界：

- 覆盖：分层导航（L0/L1/L2）、请求/结果队列化、Graph/Overlay 版本化、streaming/corridor 约束。
- 不覆盖：编辑器烘焙工具链细节、地形制作流程、算法最优化细节推导。

## 1.2 设计目标

1. 大世界可行：在 streaming 场景下避免全域常驻与全域扫描。
2. 成本可控：请求、视图装配、求解都必须有硬上限并可审计。
3. 零 GC 热路径：求解与写回阶段不产生托管分配，不依赖扩容与隐式迭代器。
4. 确定性：排序/选择/tie-break 固定；同一输入产生一致输出。
5. 模块解耦：导航核心不直接依赖平台物理与渲染；平台差异通过规则化输入或适配层注入。

## 1.3 设计思路

- 把大世界寻路拆成“范围约束问题 + 局部求解问题”：先确定 corridor，再在 corridor 内精确求解。
- 图结构与规则解耦：图尽量只读、低频更新；动态封路/改权通过 Overlay 表达并版本化。
- 请求/结果用句柄与队列闭环：实体不持有路径本体，只持有 handle；系统持有 PathStore。

# 2 功能总览

## 2.1 术语表

| 术语 | 定义 | 备注 |
|------|------|------|
| L0 骨干层 | chunk/portal 级粗粒度图 | 控节点规模，适合预计算 |
| L1 走廊层 | 由粗路径扩张得到 corridor | 限定 loaded set 与合图范围 |
| L2 局部层 | corridor 内的局部 NodeGraph | 精确 A*（含 Overlay/Tag） |
| PathRequest | 路径请求契约 | 队列化、预算化 |
| PathResult | 路径结果契约 | 只含 handle 与统计 |
| PathStore | 路径存储 | 句柄化（Index+Generation） |
| LoadedView | 局部视图 | corridor 内装配出的局部图 |
| Overlay | 动态封路/改权 | 版本化、可审计 |

## 2.2 功能导图

```
上层系统（AI/GAS/GraphRuntime）
  │  产生 PathRequest（预算化、确定性排序）
  ▼
PathRequestQueue（固定容量）
  │
  ├─（阶段A：范围约束）粗规划 L0 → corridor L1 → 确认 loaded set
  │
  └─（阶段B：精确求解）在 LoadedView(L2) 上求解 → PathStore 写入 → 产出 PathResult
  ▼
PathResultQueue（固定容量）
  │
  ▼
ApplyResults（主线程写回实体 PathHandle/状态）
  │
  ▼
FollowPath（路径跟随输出期望速度/行为）
```

## 2.3 架构图

```
┌───────────────────────────────────────────────────────────────┐
│ Navigation Runtime                                              │
│  ┌──────────────┐   ┌──────────────────┐   ┌────────────────┐ │
│  │ RequestQueue  │→  │ Corridor/Loaded  │→  │ Solve (A*)     │ │
│  │ (fixed cap)   │   │ View Builder     │   │ (workspace TL) │ │
│  └──────────────┘   └──────────────────┘   └────────────────┘ │
│           │                          │               │         │
│           ▼                          ▼               ▼         │
│     ResultQueue                GraphStore       PathStore       │
│     (fixed cap)              (NodeGraph+        (handle + data) │
│                               overlay ver)                     │
└───────────────────────────────────────────────────────────────┘
        ▲                         ▲                       ▲
        │                         │                       │
  Map/Terrain                 Spatial Service           Physics
```

## 2.4 关联依赖

- 地图与地形：`docs/04_游戏逻辑/09_地图与地形/*`
- 空间服务：`docs/03_基础服务/06_空间服务/*`
- 物理系统：`docs/03_基础服务/07_物理系统/*`

# 3 业务设计

## 3.1 业务用例与边界

用例：

1. 单位从当前位置移动到远处目标点（跨多个 chunk）。
2. 目标移动时重算路径（按 RepathPolicy）。
3. 动态封路/开路导致路径失效（overlayVersion 变化）。

边界：

- 路径跟随与避障属于消费路径的上层能力（移动/AI/Steering）；导航只提供路径句柄与必要查询。
- 图更新属于写阶段资源更新管线，不与并行求解混用。

## 3.2 业务主流程

```
Tick N:
  1) CollectRequests: 生成 PathRequest（包含预算、版本快照）
  2) PlanCorridor: L0 粗规划 → corridor（显式 chunk 集合）
  3) EnsureLoaded: 如 corridor 未加载齐，返回 Pending 或 CoarseOnly
  4) Solve: 在 LoadedView(L2) 求解 → 写入 PathStore → 产出 PathResult
  5) ApplyResults: 写回实体 PathHandle 与状态
```

## 3.3 关键场景与异常分支

- corridor 超预算：降级为 CoarseOnly 或缩小半径重算（最多一次）。
- maxExpanded 超预算：返回 BudgetExceeded（必须可审计）。
- graphVersion/overlayVersion 变化：旧路径标记 stale，由上层按策略重新发请求（不做隐式修补）。

# 4 数据模型

## 4.1 概念模型

- GraphStore：持有 NodeGraph 与版本号（graphVersion），以及 overlay 的句柄与 overlayVersion。
- PathStore：管理 PathHandle（Index+Generation）到路径数据片段的映射。
- Request/Result：通过固定容量队列传递，不把路径数据塞进组件。

## 4.2 数据结构与不变量

- NodeGraph 在读阶段只读；写阶段更新必须与求解阶段隔离。
- PathHandle 必须携带 generation 校验；组件内禁止裸指针。
- RequestQueue/ResultQueue 固定容量；超限必须丢弃并计数，不允许扩容。

## 4.3 生命周期/状态机

- PathRequest：Queued → PlanningCorridor → WaitingChunks → Solving → Ready/Failed
- 实体侧：PathHandle + PathFollowState + RepathPolicy

# 5 落地方式

## 5.1 模块划分与职责

- Requesting：生产 PathRequest（AI/GAS/GraphRuntime）
- Planning：L0 粗规划 + corridor 计算 + streaming 约束
- Solving：L2 局部求解（A*）+ workspace 复用
- Applying：主线程写回结果 + 回收旧 handle

## 5.2 关键接口与契约

接口契约由本目录 02_接口规范定义。

## 5.3 运行时关键路径与预算点

- 每帧 PathRequest 出队上限（N requests/frame）
- 每请求 A* maxExpanded 上限
- corridor 半径与最大 chunk 数上限
- LoadedView 装配缓存命中率（避免重复合图）

# 6 与其他模块的职责切分

## 6.1 切分结论

- Navigation 只负责路径计算与路径句柄管理，不负责业务决策。
- Spatial 负责世界→节点投影与空间查询输入输出标准化；Navigation 不直接依赖平台物理。
- Map/Terrain 提供几何真源与分块口径；NavGraph/NavTile 从其派生并版本化。

## 6.2 为什么如此

- 大世界瓶颈主要来自 streaming 与视图装配；将其抽出可独立预算与优化。
- 句柄化与队列化能把并行安全与生命周期问题集中管理。

## 6.3 影响范围

- `src/Core/Navigation/*`

# 7 当前代码现状

## 7.1 现状入口

- `src/Core/Navigation/GraphCore/*`
- `src/Core/Navigation/GraphWorld/*`
- `src/Core/Navigation/GraphEcs/*`

## 7.2 差距清单

- 请求/结果缺少统一固定容量队列与 dropped 统计口径。
- LoadedView 装配存在“全量合图重建”风险路径，需要 corridor 缓存/增量策略。

## 7.3 迁移策略与风险

- 迁移优先顺序：先固化队列与 PathStore 句柄，再优化 GraphWorld 视图装配。

# 8 验收条款

1. 远距离请求下 corridor chunk 数可被上限约束，且超限时降级行为可观测。
2. 路径求解阶段无托管分配（零 GC 热路径），并输出 expanded/maxExpanded 与 dropped 统计。
3. streaming 高频变化下不出现频繁全量合图重建；LoadedView 装配具备缓存命中与版本化口径。

