---
文档类型: 架构设计
创建日期: 2026-02-05
最后更新: 2026-02-05
维护人: X28技术团队
文档版本: v0.1
适用范围: 游戏逻辑 - 地图与地形 - 地图加载流程
状态: 草案
---

# 地图加载流程 架构设计

# 1 设计概述
## 1.1 本文档定义

本文档定义 Ludots 当前版本的“地图加载”编排口径：MapConfig 如何从 Core + Mods 合并、地形二进制如何读取、实体如何装配、以及 MapLoaded 事件作为后续逻辑的唯一入口。

边界与非目标：

- 边界：只覆盖“加载期的数据与装配”，不覆盖加载完成后的玩法系统运行细节。
- 非目标：不在加载阶段执行任何玩法逻辑（AI/战斗/经济等），也不在本文档设计跨版本兼容与静默 fallback。

## 1.2 设计目标

- 单一真实来源：MapConfig 合并规则与入口唯一且可解释。
- 可扩展：Mods 可新增地图与覆盖字段，并可选择性提供 Hex/Grid/Graph 数据集，但必须受清晰约束（命名、路径、合并策略、唯一性裁决）。
- 可诊断：缺文件、版本不匹配、schema 不匹配应在加载期暴露且可定位（目标口径为 fail-fast）。
- 边界清晰：MapLoaded 为切图后续逻辑的唯一触发点。

## 1.3 设计思路

- 分两类数据源处理：
  - MapConfig：面向“地图内容编排”（实体模板、标签、依赖、地形文件引用）。
  - 地形几何真源：面向“世界边界与几何场信息”（高度/阻挡/水面等）。
- 以 GameEngine 作为加载编排器，MapManager/MapLoader/VertexMapBinary 作为职责明确的落地模块。

# 2 功能总览
## 2.1 术语表

- MapId：地图标识（强类型包装）。
- MapConfig：地图配置（可合并，来自 Core + Mods），包含 Tags/Entities/DataFile 等。
- DataFile：地形二进制文件路径（相对 assets 根的相对路径），用于 Hex(VertexMap)（历史字段）。
- MapDataSet：地图数据集（目标形态），用于描述 Hex/Grid/Graph 等可选加载内容以及其叠加规则。
- VFS：虚拟文件系统，使用 `ModId:relative/path` 寻址。
- MapLoaded：地图完成装配后的事件键，用于触发后续逻辑。
- Hex 系统：基于 VertexMap 的六边形/三角网格地形真源（地表/水体/阻挡等）。
- Grid 系统：大颗粒/小颗粒网格场（天气、流场等），可多份并存与叠加。
- Graph 系统：路网（导航图），支持分块加载、多层（coarse/fine）与 overlay（成本/封路）。

说明：项目内存在两类“Graph”概念，必须区分：

- 路网 Graph：`src/Core/Navigation/*`（用于寻路与路网语义）。
- GASGraph：`src/Core/Gameplay/GAS/Graph/*`（用于技能/效果节点图运行时，不属于地图路网真源）。

## 2.2 功能导图

- 地图配置合并（Core+Mods → MapConfig）
- Hex 地形二进制读取（DataFile → VertexMap，可选）
- Grid 场数据加载（coarse/fine，可选，可多份）
- Graph 路网加载（分块/多层/overlay，可选，可多份）
- 模板装配与实体生成（templates.json + MapConfig.Entities → ECS Entities）
- 事件触发（MapLoaded）

## 2.3 架构图

```
            +------------------+
            |   GameEngine     |
            |  (LoadMap)       |
            +--------+---------+
                     |
     +---------------+----------------+
     |                                |
     v                                v
+------------+                 +---------------+
| MapManager |                 | LoadVertexMap |
| (MapConfig)|                 | (VertexMap)   |
+------+-----+                 +-------+-------+
       |                               |
       v                               v
+------+-----+                 +-------+-------+
|  MapLoader  |                 | VertexMapBinary|
| (Entities)  |                 | (Read/Write)   |
+------+-----+                 +-------+--------+
       |
       v
  TriggerManager.FireEvent(MapLoaded)
```

## 2.4 关联依赖

- 配置合并基础设施：`src/Core/Config/ConfigPipeline.cs`、`src/Core/Config/DataRegistry.cs`
- 模板体系：`src/Core/Config/EntityBuilder.cs`、`src/Core/Config/EntityTemplate.cs`
- 事件/触发器：`src/Core/Scripting/TriggerManager.cs`、`src/Core/Scripting/GameEvents.cs`
- 资源寻址：`src/Core/Modding/VirtualFileSystem.cs`

# 3 业务设计
## 3.1 业务用例与边界

- 用例：加载指定 MapId，完成“配置合并 + 地形加载 + 实体装配”，并触发 MapLoaded 供 Mod/系统继续初始化。
- 边界：加载流程不应隐式触发战斗/AI/经济等系统；这些逻辑必须在 MapLoaded 之后由触发器或系统显式执行。

## 3.2 业务主流程

```
LoadMap(mapId)
  -> MapManager.LoadMap(mapId) 合并 MapConfig（Core + Mods + Parent 链）
  -> ResolveMapDataSets(mapConfig) 裁决数据集（Vertex 唯一；Grid/Graph 可叠加）
  -> LoadHexVertexMap(mapConfig) 读取地形二进制（可选）
  -> LoadGrids(mapConfig) 加载 coarse/fine 网格场（可选，可多份）
  -> LoadGraphs(mapConfig) 加载路网（可选，可多份；支持 overlay）
  -> MapLoader.LoadEntities(mapConfig) 基于模板创建实体（模板先，Overrides 后）
  -> TriggerManager.FireEvent(GameEvents.MapLoaded, ctx)
```

## 3.3 关键场景与异常分支

- MapConfig 未找到：应失败并给出候选路径与 ModId 证据。
- Hex 数据缺失：若地图最终裁决需要 Hex(Vertex) 但文件不存在，应在加载期失败并给出证据。
- 二进制版本不匹配：应失败并提示期望版本与实际版本。
- schema 不匹配：MapConfig JSON 字段结构错误（例如 Dependencies 类型不匹配）应失败并给出定位信息。
- Vertex 唯一性冲突：同一最终 MapConfig 下出现多个不同的 Vertex 来源，应在加载期直接失败并输出冲突来源证据。

# 4 数据模型
## 4.1 概念模型

- MapConfig：描述“本地图要装配什么”，是地图内容编排的 SSOT。
- Hex(VertexMap)：描述“地形几何/水体/阻挡”等，作为地表真源输入（可选，且每张最终地图最多 1 份）。
- Grid（目标形态）：描述天气/流场等场数据，允许粗/细两套甚至更多套并存与叠加。
- Graph（目标形态）：描述路网，允许多网络/多层，并允许 overlay 叠加（静态+运行期）。

## 4.2 数据结构与不变量

- MapConfig（`src/Core/Config/MapConfig.cs`）
  - `Id`：与请求的 MapId 一致（理想不变量，当前代码未强校验）。
  - `ParentId`：可选；存在时加载期解析并合并（禁止运行时猜测）。
  - `DataFile`：可选；声明则应可加载为 VertexMapBinary（历史字段；目标形态将由 MapDataSet 替代）。
  - `Entities`：实体生成清单，必须引用已存在模板。
- VertexMapBinary（`src/Core/Map/Hex/VertexMapBinary.cs`）
  - magic=`VTXM`，version=2，chunkSize 必须等于 `VertexChunk.ChunkSize`。

不变量（目标口径）：

- Vertex 唯一性：对同一 MapId 的最终合并结果，Hex(Vertex) 真源最多 1 份，且不允许静默覆盖。
- 数据集叠加有序：Grid/Graph 的多份叠加必须可解释（按 id + 合并策略），禁止 silent override。

## 4.3 生命周期/状态机

- 未加载：MapConfig/VertexMap 为空或未初始化
- 加载中：合并配置 / 读取地形 / 装配实体
- 已加载：MapLoaded 触发后进入运行期（后续系统可读 ContextKeys.MapId/MapTags/VertexMap 等）

# 5 落地方式
## 5.1 模块划分与职责

- GameEngine：加载编排与生命周期边界；组织上下文并触发 MapLoaded。
- MapManager：按 MapId 收集 Core+Mods 的 MapConfig 片段并合并为最终 MapConfig。
- MapLoader：加载模板注册表并根据 MapConfig.Entities 生成实体。
- VirtualFileSystem：统一资源寻址；Core 与 Mods 都通过 `ModId:path` 打开流。
- VertexMapBinary：地形二进制的读写与版本校验。
- Grid/Graph Loader（目标形态）：按 MapDataSet 裁决结果加载 Grid/Graph，并注入 MapLoaded 上下文。

## 5.2 关键接口与契约

- `IMapManager.LoadMap(MapId)`：必须返回最终 MapConfig 或明确失败原因。
- `MapLoader.LoadTemplates()`：必须在任何实体装配前完成。
- `LoadVertexMap(MapConfig)`：若地图声明 DataFile，则必须在加载期给出成功/失败的确定性结果。

## 5.3 运行时关键路径与预算点

- MapConfig 合并：随 Mod 数量与片段数线性增长；应避免重复 IO 与重复 JSON 解析。
- VertexMapBinary：按 chunk 顺序读取，内存分配较重；应避免每次切图重复分配临时缓冲（后续可优化）。

# 6 与其他模块的职责切分
## 6.1 切分结论

- ConfigPipeline/DataRegistry：负责“列表型/注册表型配置”的通用合并，不承担 MapConfig 的主裁决。
- MapManager：负责 MapConfig 合并的 SSOT。
- TriggerManager：只负责事件触发与触发器执行，地图加载流程本身不应下沉到 Trigger 链路内。

## 6.2 为什么如此

MapConfig 的合并规则与路径约定更偏“业务域”，需要更强的可解释性与约束；通用 ConfigPipeline 更适合处理通用注册表与配置覆盖，不适合作为地图业务的唯一裁决点。

## 6.3 影响范围

- Mod 作者需要遵循 MapConfig schema 与路径约定，否则加载期应直接失败（目标口径）。
- 上层系统只能依赖 MapLoaded 与 ContextKeys 提供的上下文，不得绕过加载边界。

# 7 当前代码现状
## 7.1 现状入口

- `src/Core/Engine/GameEngine.cs`：LoadMap/LoadVertexMap/MapLoaded 触发点
- `src/Core/Map/MapManager.cs`：MapConfig 片段查找与合并
- `src/Core/Systems/MapLoader.cs`：模板加载与实体装配
- `src/Core/Map/WorldMap.cs` 与 `src/Core/Map/Hex/VertexMap*.cs`：两套地形/几何表示并存

## 7.2 差距清单

- 加载期 fail-fast 未落地：MapManager/LoadVertexMap 存在“吞异常/静默返回”的路径，导致缺文件或 schema 错误不会被立即定位。
- MapConfig schema 不一致风险：仓库内部分地图 JSON 使用 `Dependencies: []` 数组结构，但代码期望 `Dictionary<string,string>`，会导致反序列化异常被吞掉后“地图不存在”。
- 路径约定混杂：Core 与 Mods 的路径前缀（`Configs/`、`assets/`、`assets/Data/Maps/`）在 MapManager 与 LoadVertexMap 中分别硬编码，存在重复与不一致。
- 地形表示并存：WorldMap 与 VertexMap 同时存在且单位/网格口径不同，缺少“谁是几何真源”的强约束说明。
- Vertex 唯一性裁决缺失：同一地图的多片段合并时，DataFile 会被后者覆盖但不报冲突（与“每张最终地图 Vertex 唯一”口径不一致）。
- Grid/Graph 地图级接线缺失：WorldMap 的二进制加载仍为占位；路网 Graph 基建较完整但未接入 LoadMap/MapLoaded 上下文；与 GASGraph 的概念边界也缺少明确文档化。

## 7.3 迁移策略与风险

- 迁移策略：以“加载期强约束”为原则，逐步把吞错改为“收集候选路径+明确报错”；对 MapConfig schema 做一次性迁移并在加载期校验。
- 风险：一旦开启 fail-fast，历史不合规 Mod/配置会在启动期直接失败，需要同步提供迁移工具或清晰错误信息。

# 8 验收条款

- 缺失 MapConfig：请求不存在的 MapId 时，必须输出候选查找路径与加载来源证据，并返回失败（可用单测/集成测试验证）。
- schema 不匹配：MapConfig JSON 字段类型错误时，必须在加载期报错并给出文件路径与字段名（可用单测验证）。
- DataFile 缺失/版本不匹配：声明了 DataFile 但缺文件或版本不匹配时，必须在加载期失败并给出期望/实际信息（可用构造的坏二进制用例验证）。
