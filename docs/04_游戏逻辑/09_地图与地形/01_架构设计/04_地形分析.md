---
文档类型: 架构设计
创建日期: 2026-02-05
最后更新: 2026-02-05
维护人: X28技术团队
文档版本: v0.1
适用范围: 游戏逻辑 - 地图与地形 - 地形分析
状态: 草案
---

# 地形分析 架构设计

# 1 设计概述
## 1.1 本文档定义

本文档定义“地形分析”的语义口径：如何从地形真源（WorldMap/VertexMap）派生出可行走性、渲染表现与导航输入所需的数据与规则。

边界与非目标：

- 边界：只讨论地形语义与派生规则，不讨论具体算法实现细节（例如完整 NavMesh 构建）。
- 非目标：不在运行期隐式猜测缺失数据；缺失应在加载期暴露（目标口径）。

## 1.2 设计目标

- 统一口径：阻挡/坡道/水面等语义只应有一个真源输入与一套派生规则。
- 可诊断：分析结果可回溯到输入层（layer）与规则参数。
- 可扩展：允许 Mod 引入新层与新规则，但必须通过显式版本化与契约更新。

## 1.3 设计思路

- “输入层（layers）”与“派生规则（rules）”分离：layers 由地图资产提供，rules 由 Core 或 Mod 配置/代码提供。
- 分析输出应面向消费方（导航/渲染/碰撞）而不是面向存储形式。

# 2 功能总览
## 2.1 术语表

- Layer：地形基础层（height/biome/water/blocked/ramp/…）。
- Rule：把 layers 映射为语义的规则（例如颜色、可行走性、坡度限制）。
- Consumer：消费方（渲染、导航、碰撞/物理等）。

## 2.2 功能导图

- 输入：VertexMap/WorldMap layers
- 分析：可行走性判定、坡道/高度差处理、渲染颜色规则
- 输出：NavMesh 输入、Debug/渲染 mesh、碰撞/阻挡查询

## 2.3 架构图

```
Terrain SSOT (VertexMap/WorldMap)
  -> Terrain Rules
      -> Walkability / Nav Input
      -> Visual Mesh / Color
      -> Debug Queries
```

## 2.4 关联依赖

- VertexMap layers：`src/Core/Map/Hex/VertexMap.cs`
- 渲染规则示例：`src/Core/Presentation/Rendering/VertexMapChunkMeshBuilder.cs`

# 3 业务设计
## 3.1 业务用例与边界

- 用例：在运行期高频查询某坐标是否阻挡、某点高度与水面高度；为导航与渲染构建派生数据。
- 边界：分析只读取地形输入，不直接依赖具体玩法实体状态（那属于更上层的 overlay）。

## 3.2 业务主流程

```
OnMapLoaded
  -> 获取 VertexMap/WorldMap
  -> (可选) 预计算派生数据（navmesh/mesh）
  -> 运行期查询：IsBlocked/Height/Water/…
```

## 3.3 关键场景与异常分支

- 地形真源为空：地图未声明 DataFile 或加载失败时，消费方必须明确处理（避免默认值掩盖错误）。
- 多真源漂移：WorldMap 与 VertexMap 同时被不同系统使用时，必须明确优先级或禁止同时启用。

# 4 数据模型
## 4.1 概念模型

- 基础层：由地图资产提供（VertexMapBinary/运行期编辑）。
- 派生层：由规则计算得到（颜色、可行走性、坡道裁决等）。

## 4.2 数据结构与不变量

- 阻挡（Blocked）是可行走性判定的底层输入之一，但不应单独作为“最终可行走性”口径（还可能叠加水面/高度差/坡度等规则）。
- 高度层的单位与坐标系必须与渲染/导航的空间口径一致（避免单位漂移）。

## 4.3 生命周期/状态机

- 地图加载后：地形输入就绪（或明确为空）
- 运行期：可选的派生缓存存在时，需要明确更新策略（当前版本未统一）

# 5 落地方式
## 5.1 模块划分与职责

- 输入层：VertexMap/WorldMap
- 规则层：TerrainVisualRules 等（当前散落在消费方侧）
- 查询入口：建议集中到 TerrainQueryService（目标形态，当前未落地）

## 5.2 关键接口与契约

- `IsBlocked/Height/WaterHeight/Ramp` 等查询在边界外的返回语义必须一致并文档化（默认值 vs 失败）。

## 5.3 运行时关键路径与预算点

- 高频查询路径需要避免多次字典查找与过多分支；chunk 缓存与预计算可作为优化方向。

# 6 与其他模块的职责切分
## 6.1 切分结论

- 地形分析只负责“从地形真源派生语义”，不负责 Mod 脚本触发、实体装配或玩法状态。

## 6.2 为什么如此

把分析与玩法解耦能保证地形口径稳定，避免不同玩法系统各自实现一套阻挡/高度规则造成漂移。

## 6.3 影响范围

- 导航/渲染/物理需要引用同一套规则与查询入口，否则会出现体验不一致。

# 7 当前代码现状
## 7.1 现状入口

- VertexMap 层访问：`src/Core/Map/Hex/VertexMap.cs`
- 渲染侧规则与投影：`src/Core/Presentation/Rendering/VertexMapChunkMeshBuilder.cs`

## 7.2 差距清单

- 缺少集中式“地形查询/分析服务”，规则散落在消费方侧，存在口径漂移风险。
- 地形真源为空时缺少统一失败策略（默认值可能掩盖缺资产/加载失败）。

## 7.3 迁移策略与风险

- 优先补齐：加载期对 DataFile/schema 的强校验与明确错误信息。
- 再引入：统一的 TerrainQueryService，把规则与边界语义收敛到单点。

# 8 验收条款

- 在同一地图中，渲染/导航/阻挡查询必须使用同一真源与一致的坐标/单位口径（对齐验证）。
- 地形真源缺失时必须有可定位错误输出或显式禁用相关消费方（不得静默 fallback）。
- 新增地形规则必须可回溯到输入 layers 与规则参数，并可通过测试或工具验证。
