---
文档类型: 架构设计
创建日期: 2026-02-05
最后更新: 2026-02-05
维护人: X28技术团队
文档版本: v0.1
适用范围: 游戏逻辑 - 地图与地形 - 地图实体装配流程
状态: 草案
---

# 地图实体装配流程 架构设计

# 1 设计概述
## 1.1 本文档定义

本文档定义地图加载后的“实体示例初始化”口径：EntityTemplate 如何从 Core+Mods 合并、MapConfig.Entities 如何驱动生成实体、Overrides 如何覆盖模板组件，以及该流程与 MapLoaded 的边界。

边界与非目标：

- 边界：只覆盖“模板/装配/Overrides”的加载期行为，不覆盖运行期能力系统、AI 或渲染同步。
- 非目标：不在此文档定义跨版本兼容与静默 fallback；未知模板/未知组件应遵循 fail-fast（目标）或至少输出可定位错误信息（现状仍偏宽松）。

## 1.2 设计目标

- 可解释：同一份 mapId + 同一套 ModPaths 下，实体生成结果可追溯到模板与 overrides。
- 可扩展：Mods 可新增模板与覆盖模板字段；地图可追加实体清单。
- 口径稳定：模板先、Overrides 后；Overrides 同名字段覆盖模板。

## 1.3 设计思路

- 模板层与实例层分离：
  - 模板层（EntityTemplate）：描述“一个实体默认应包含哪些组件及其默认值”。
  - 实例层（EntitySpawnData）：描述“在地图上生成一个实体并覆盖哪些字段”。
- 合并策略分层：
  - templates.json：按模板 Id 合并（同 Id 对象 merge）。
  - MapConfig.Entities：列表追加（多个来源叠加生成更多实体）。

# 2 功能总览
## 2.1 术语表

- EntityTemplate：实体模板（Id + 组件字典）。
- templates.json：模板注册表文件路径（相对路径 `Entities/templates.json`）。
- EntitySpawnData：地图实体生成条目（Template + Overrides）。
- Overrides：实例级覆盖数据（componentName → JsonNode）。

## 2.2 功能导图

- 加载模板：Core+Mods 的 templates.json 合并 → TemplateRegistry
- 加载地图：MapConfig 合并 → Entities 列表
- 生成实体：UseTemplate → WithOverride → Build

## 2.3 架构图

```
templates.json(Core+Mods)
  -> DataRegistry<EntityTemplate>
      -> EntityBuilder(UseTemplate + Overrides)
          -> ECS Entity

MapConfig(Core+Mods+Parent)
  -> Entities[]
```

## 2.4 关联依赖

- MapLoader：`src/Core/Systems/MapLoader.cs`
- DataRegistry/ConfigPipeline：`src/Core/Config/DataRegistry.cs`、`src/Core/Config/ConfigPipeline.cs`
- EntityBuilder：`src/Core/Config/EntityBuilder.cs`
- ComponentRegistry：`src/Core/Config/ComponentRegistry.cs`
- MapConfig：`src/Core/Config/MapConfig.cs`

# 3 业务设计
## 3.1 业务用例与边界

- 用例：地图 entry 在加载时生成 hero 与 dummy 等演示实体，并通过 Overrides 指定位置与名称。
- 边界：实体生成完成后，后续玩法初始化应通过 MapLoaded 触发（而不是在 LoadEntities 中直接写玩法逻辑）。

## 3.2 业务主流程

```
GameEngine.LoadMap(mapId)
  -> MapManager.LoadMap(mapId) 得到最终 MapConfig（含 Entities 列表）
  -> MapLoader.LoadTemplates() 预先加载 templates.json（Core+Mods 合并）
  -> MapLoader.LoadEntities(mapConfig)
     - foreach EntitySpawnData:
         builder.UseTemplate(templateId)
         foreach override:
           builder.WithOverride(componentName, json)
         builder.Build()
  -> MapLoaded 事件触发（后续逻辑入口）
```

## 3.3 关键场景与异常分支

- 模板不存在：现状会输出 warning 并只用 overrides 生成实体（宽松口径）；目标口径建议在开发/测试环境 fail-fast。
- overrides 为 null：现状会 warning 并跳过；目标口径应给出 mapId + entity index 的定位信息。
- 组件注册缺失：ComponentRegistry.Apply 若找不到组件，目标口径应 fail-fast 并定位模板/字段来源。

# 4 数据模型
## 4.1 概念模型

- EntityTemplate：默认组件集
- EntitySpawnData：实例化请求
- Overrides：对默认组件集的差异化补丁

## 4.2 数据结构与不变量

- 应用顺序不变量：模板先 → overrides 后（同名覆盖）。
- overrides 命中模板组件时，模板该组件跳过，以 overrides 为准。

## 4.3 生命周期/状态机

- 初始化：引擎启动后加载 templates.json（Core+Mods）。
- 切图：每次 LoadMap 时根据 MapConfig.Entities 生成一批实体（是否销毁旧实体取决于上层设计，当前文档只描述生成侧）。

# 5 落地方式
## 5.1 模块划分与职责

- MapLoader.LoadTemplates：加载并合并 templates.json。
- MapLoader.LoadEntities：消费 MapConfig.Entities，驱动 EntityBuilder 构建实体。
- EntityBuilder：执行模板与 overrides 的应用顺序。

## 5.2 关键接口与契约

- templates.json 合并口径：Core → Mods，遇到同 Id 用对象 merge（晚加载覆盖早加载字段）。
- Entities 叠加口径：MapConfig 合并时 Entities 采用追加列表（多个来源会生成更多实体）。
- Overrides 口径：Overrides 永远覆盖模板同名组件。

## 5.3 运行时关键路径与预算点

- LoadEntities 当前会把 TemplateRegistry 快照成字典；大量实体生成时可能有额外开销（属于后续优化点，不影响口径）。

# 6 与其他模块的职责切分
## 6.1 切分结论

- 地图实体装配只负责“生成实体与应用默认/覆盖组件”，玩法系统初始化必须在 MapLoaded 之后执行。

## 6.2 为什么如此

把“装配”和“玩法”解耦能保证加载流程可测试且稳定，避免地图加载阶段执行复杂业务导致边界不清。

## 6.3 影响范围

- Mod 作者可通过 templates.json 提供模板，并通过 map config 的 Entities 列表在地图加载时生成实体。

# 7 当前代码现状
## 7.1 现状入口

- MapLoader.LoadTemplates：`src/Core/Systems/MapLoader.cs`
- MapLoader.LoadEntities：`src/Core/Systems/MapLoader.cs`
- EntityBuilder：`src/Core/Config/EntityBuilder.cs`
- 示例地图：`assets/Configs/Maps/entry.json`
- 示例模板：`assets/Configs/Entities/templates.json`

## 7.2 差距清单

- 失败策略偏宽松：未知模板/override null 等仅 warning，缺少“可定位的 fail-fast”与统一诊断口径。
- MapConfig schema 风险会导致地图配置被吞错（见对齐报告），从而间接影响实体生成是否发生。

## 7.3 迁移策略与风险

- 先补齐文档与对齐报告：把模板合并、entities 叠加、overrides 顺序写成可裁决口径。
- 再逐步收紧失败策略：在开发/测试环境开启 fail-fast，并给出 mapId/templateId/componentName 的定位信息。

# 8 验收条款

- 以 entry 地图为例，实体生成结果可通过 templates.json + entry.json 的 overrides 推导，并与运行时一致。
- overrides 必须覆盖模板同名组件，且覆盖行为不依赖加载顺序或隐藏规则。
- 任何配置错误（模板缺失/组件缺失/schema 错误）必须给出可定位证据入口（文件路径/字段名/来源）。
