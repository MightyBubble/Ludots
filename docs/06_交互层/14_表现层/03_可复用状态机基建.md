---
文档类型: 架构设计
创建日期: 2026-02-05
最后更新: 2026-02-05
维护人: X28技术团队
文档版本: v0.1
适用范围: 交互层 - 表现层 - 状态机基建
状态: 草案
---

# 可复用状态机基建 架构设计

# 1 设计概述
## 1.1 本文档定义
本文档定义一套可复用的状态机基建，用于在多个子系统中以统一口径表达“Layer + 条件 + 状态选择”。

该基建以 Arch ECS 最佳实践为约束，目标是成为“纯数据 + 纯函数”的 Resolver：系统层只负责从组件/缓存取输入、调用 Resolver 得到输出、写回组件或缓冲。

非目标：

- 不定义具体子系统的状态含义（动画、AI、UI 各自定义 StateId）。
- 不在本文定义平台适配层或渲染输出。

## 1.2 设计目标
- 统一口径：tag 驱动、param 门控、layer 叠加、condition 预设类一致。
- 0GC：运行期只做数组访问与少量位运算，不分配、不装箱。
- 可编译：图结构在加载期编译为紧凑数组，运行期只按索引查表。
- 可诊断：输出应包含“为何选中某状态”的可追踪信息入口，至少支持 debug 模式下记录落选原因。

## 1.3 设计思路
- 将状态机拆成三块：Graph、Runtime、Resolver。
- Graph 是只读、可序列化、可编译的配置数据。
- Runtime 是每个实例（通常是实体）的最小运行时状态。
- Resolver 是纯函数：`(Graph, Inputs, Runtime) -> Runtime'`。

# 2 功能总览
## 2.1 术语表
- Graph：状态机图的只读数据（编译后）。
- Layer：叠加层，每层独立选出一个激活状态。
- StateId：状态标识，统一用 int，由上层系统定义其语义。
- TagMask：Tag 位集（4×ulong），来源通常为 `GameplayTagEffectiveCache`。
- ParamBlock：定长参数块，float 数组，来源由上层系统决定（可从 AttributeId 绑定）。
- ConditionSet：一组条件集合，默认全部通过才算通过。

## 2.2 功能导图
- 输入：TagMask、ParamBlock、可选的额外离散输入（例如当前 LODLevel）。
- 处理：候选状态枚举、条件评估、优先级选优、layer 权重计算、计时与混合策略更新。
- 输出：每层 ActiveStateId、每层计时与混合状态、可选的权重与模式信息。

## 2.3 架构图
```text
实体组件/缓存
  TagMask + ParamBlock + 其他输入
        |
        v
StateMachine Resolver (纯函数)
        |
        v
StateMachineRuntime (写回组件)
        |
        v
上层系统映射输出 (动画播放快照 / AI动作 / UI状态)
```

## 2.4 关联依赖
- Tag 位集口径：`src/Core/Gameplay/GAS/Components/GameplayTagEffectiveCache.cs`
- Tag 变化口径：`src/Core/Gameplay/GAS/Components/GameplayTagEffectiveChangedBits.cs`
- 文档依赖：`docs/01_底层框架/01_ECS基础/07_使用手册/01_Query与System.md`

# 3 业务设计
## 3.1 业务用例与边界
复用场景：

- 动画状态机：状态即 Tag，输出动画播放快照。
- AI 状态机：状态为行为态，输入来自 Tag 与评分参数。
- UI 状态机：状态为界面模式，输入来自上下文参数与系统 Tag。

边界：

- 不负责输入采样与写入（例如 Attribute→Param 的绑定由上层系统完成）。
- 不负责输出执行（例如播放动画或执行 AI 行为由上层完成）。

## 3.2 业务主流程
```text
每帧或按需触发
  -> 上层系统准备输入 TagMask/ParamBlock
  -> 调用 Resolver 更新 Runtime
  -> 上层系统将 ActiveStateId 映射到具体动作/播放/渲染输出
```

## 3.3 关键场景与异常分支
- 图编译失败：引用了不存在的 ParamId/TagId/StateId，必须在加载期 fail-fast。
- 无候选状态：允许返回 Layer 的默认状态或 None，但必须由 Graph 显式配置，不允许运行时静默猜测。
- 条件冲突：多个状态同时满足，必须有确定性 tie-break（Priority，再以 StateId 排序等）。

# 4 数据模型
## 4.1 概念模型
- LayerDef：描述一层的候选集与权重策略。
- StateDef：描述一个状态的优先级、条件集合与可选元信息。
- ConditionSet：由若干预设条件组成。
- Runtime：每层当前状态与计时信息。

## 4.2 数据结构与不变量
### 4.2.1 StateId 与 TagMask 的关系
- 基建不强制 StateId 与 TagId 同构。
- 当上层选择“状态即 Tag”时，StateId 可以直接等于 TagId；此时候选集可用 TagMask 高效表达。

### 4.2.2 Condition 预设类
ParamCondition：

- 结构：`{ ParamId, Op, A, B }`
- Op：GT/LT/GE/LE/EQ/NE/IN_RANGE

TagCondition：

- 结构：`{ TagId, Kind }`
- Kind：Effective/NotEffective/Present/NotPresent

TagMaskCondition：

- 结构：`{ Mask(4×ulong), Mode }`
- Mode：HasAll/HasAny/ExcludeAny

不变量：

- ConditionSet 默认 AND 组合，所有条件均通过才算通过。
- 所有条件数组在 Graph 编译后为只读扁平数组，State 只保存范围索引。

### 4.2.3 Layer 与确定性
确定性选择顺序建议固定为：

1. 过滤候选集
2. 评估条件集合
3. 取最大 Priority
4. Priority 相同取最小 StateId

## 4.3 生命周期/状态机
Runtime 每层至少包含：

- ActiveStateId
- StateTimeTicks
- BlendTicks

是否推进时间与是否允许跳帧由上层（例如 LOD/Culling 策略）决定，但口径应统一写在裁决条款中。

# 5 落地方式
## 5.1 模块划分与职责
- GraphCompiler：加载期把配置编译为紧凑数组（扁平 Condition、索引化 State 表）。
- Resolver：运行期纯函数评估。
- Runtime：每实例（实体）持有的最小状态。

## 5.2 关键接口与契约
- 输入契约：TagMask 与 ParamBlock 由上层提供，必须在调用时保持稳定（只读）。
- 输出契约：Runtime 写回应是单次覆盖，禁止隐式保留旧状态导致不可解释行为。

## 5.3 运行时关键路径与预算点
- 候选枚举：候选状态数量是主要成本来源，Graph 应对每层候选集设上限并可诊断。
- 条件评估：ParamCondition 数量应可控，避免把任意脚本逻辑塞进 condition。

# 6 与其他模块的职责切分
## 6.1 切分结论
- Param 采样与绑定：不属于状态机基建，属于各子系统的输入供应层。
- 可见性与 LOD：不属于状态机基建，但可能作为额外输入由上层传入。
- 输出执行：不属于状态机基建。

## 6.2 为什么如此
- 将基建保持为纯函数，有利于测试、复用与性能审计。
- 将输入供应与输出执行留给上层，避免基建被某个子系统绑死。

## 6.3 影响范围
- Animator、AI、UI 若采用同一套 condition 预设类，可共享编译器与诊断工具。

# 7 当前代码现状
## 7.1 现状入口
- Tag 位集：`src/Core/Gameplay/GAS/Components/GameplayTagEffectiveCache.cs`
- Tag 变化：`src/Core/Gameplay/GAS/Systems/DeferredTriggerCollectionSystem.cs`

## 7.2 差距清单
- 缺少统一的通用状态机模块，导致各系统若各自实现会产生口径分叉与难以维护。

## 7.3 迁移策略与风险
- 首次引入建议先用“状态即 Tag”的 Animator 作为样例，验证抽象足够通用后再推广到 AI/UI。

# 8 验收条款
- 0GC：在 1 万实体、每帧随机输入的情况下，Resolver 不产生托管分配。
- 确定性：相同输入在不同机器/不同帧顺序下输出一致（以 Priority 与 StateId 作为稳定 tie-break）。
- 可诊断：在 debug 开关下可输出“候选集、落选原因、最终选中”三类信息入口。
